/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uk.chromis.pos.sync;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import javax.swing.Timer;
import uk.chromis.basic.BasicException;
import uk.chromis.data.loader.Datas;
import uk.chromis.data.loader.SerializerReadBasic;
import uk.chromis.data.loader.SerializerWriteString;
import uk.chromis.data.loader.StaticSentence;
import uk.chromis.pos.forms.AppConfig;
import uk.chromis.pos.forms.AppLocal;
import uk.chromis.pos.forms.AppView;
import uk.chromis.pos.forms.BeanFactoryApp;
import uk.chromis.pos.forms.BeanFactoryException;
import uk.chromis.pos.forms.JPanelView;
import uk.chromis.pos.util.AltEncrypter;

/**
 *
 * @author Dell790
 */
public class JPanelTillBranchSync extends javax.swing.JPanel implements JPanelView, BeanFactoryApp {

    private Timer t;
    public static DataLogicSync dlSync;
    
    private Connection tillConnection;
    private Connection branchConnection;
    private Date lastSyncDate;
    private String tillSiteGuid = "";
    private String branchSiteGuid = "";
    private int batchSize = 100;
    public static boolean isPreviousSyncComplete = true;
    
    public static String[] branchToTillTables = new String[]
    {
        "ROLES",
        "PEOPLE",
        "CATEGORIES",
        "TAXCATEGORIES",
        "TAXES",
        "TAXCUSTCATEGORIES",
        "FLOORS",
        "PLACES",
        "CUSTOMERS",
        "THIRDPARTIES",
        "BREAKS",
        "LOCATIONS",
        "PROMOTIONS",
        "ATTRIBUTE",
        "ATTRIBUTEVALUE",
        "ATTRIBUTESET",
        "ATTRIBUTESETINSTANCE",
        "ATTRIBUTEUSE",
        "ATTRIBUTEINSTANCE",
        "PRODUCTS",
        "PRODUCTS_COM",
        "PRODUCTS_KIT",
        "DBPERMISSIONS",
        "STOCKCURRENT"
    };

    public static String[] tillToBranchTables = new String[]
    {
        "CLOSEDCASH",
        "SHIFTS",
        "SHIFT_BREAKS",
        "LEAVES",
        "VOUCHERS",
        "RESERVATIONS",
        "RESERVATION_CUSTOMERS",
        "STOCKDIARY",
        "RECEIPTS",
        "TICKETS",
        "TICKETLINES",
        "SALES_DENORMALIZED",
        "PAYMENTS",
        "TAXLINES",
        "DRAWEROPENED",
        "LINEREMOVED"
    };
    
    /**
     * Creates new form JPanelTillBranchSync
     */
    public JPanelTillBranchSync() {
        initComponents();
        
    }
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaSyncLog = new javax.swing.JTextArea();
        jButtonConfigurations = new javax.swing.JButton();
        jButtonStartStop = new javax.swing.JButton();
        jLabelSyncStatus = new javax.swing.JLabel();
        jLabelLastSyncedAt = new javax.swing.JLabel();
        jButtonSyncNow = new javax.swing.JButton();
        jButtonClearLog = new javax.swing.JButton();

        jLabel1.setText("Sync Status:");

        jLabel3.setText("Sync Log:");

        jLabel2.setText("Last Synced at:");

        jTextAreaSyncLog.setEditable(false);
        jTextAreaSyncLog.setColumns(20);
        jTextAreaSyncLog.setRows(5);
        jScrollPane1.setViewportView(jTextAreaSyncLog);

        jButtonConfigurations.setText("Sync configurations");
        jButtonConfigurations.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonConfigurationsActionPerformed(evt);
            }
        });

        jButtonStartStop.setText("Start");
        jButtonStartStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonStartStopActionPerformed(evt);
            }
        });

        jLabelSyncStatus.setText("___");
        jLabelSyncStatus.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabelLastSyncedAt.setText("___");
        jLabelLastSyncedAt.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jButtonSyncNow.setText("Sync Now");
        jButtonSyncNow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSyncNowActionPerformed(evt);
            }
        });

        jButtonClearLog.setText("Clear Log");
        jButtonClearLog.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearLogActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 572, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 123, Short.MAX_VALUE)
                                    .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jLabelSyncStatus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jLabelLastSyncedAt, javax.swing.GroupLayout.DEFAULT_SIZE, 225, Short.MAX_VALUE))
                                .addGap(0, 0, Short.MAX_VALUE)))
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButtonClearLog)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonSyncNow)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButtonConfigurations)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonStartStop)
                        .addGap(2, 2, 2))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabelSyncStatus))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jLabelLastSyncedAt))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addGap(10, 10, 10)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 169, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonClearLog)
                    .addComponent(jButtonSyncNow)
                    .addComponent(jButtonConfigurations)
                    .addComponent(jButtonStartStop))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonStartStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonStartStopActionPerformed

        boolean isTillBranchSyncStarted = this.dlSync.isTillBranchSyncStarted();
        boolean newValue = !isTillBranchSyncStarted;
        this.dlSync.updateIsTillBranchSyncStarted(newValue);
        
        this.enableDisableButtons();
        updateLog();
    }//GEN-LAST:event_jButtonStartStopActionPerformed

    private void jButtonConfigurationsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonConfigurationsActionPerformed
        
        JDialogTillBranchSyncConfig configFrom = new JDialogTillBranchSyncConfig(null, true, this.dlSync);
        configFrom.setVisible(true);
    }//GEN-LAST:event_jButtonConfigurationsActionPerformed

    private void jButtonClearLogActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearLogActionPerformed
        
        try
        {
            this.dlSync.clearTillBranchSyncLog();
            JOptionPane.showMessageDialog(null, "Log cleared successfully");
            updateLog();
        }
        catch(Exception ex)
        {
            JOptionPane.showMessageDialog(null, "Error: "+ ex.getMessage());
        }
    }//GEN-LAST:event_jButtonClearLogActionPerformed

    private void jButtonSyncNowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSyncNowActionPerformed
        
        if(isPreviousSyncComplete)
        {
            SwingWorker syncWorker = this.createSyncWorker();
            syncWorker.execute();
            JOptionPane.showMessageDialog(null, "Sync Started");
        }
        else
        {
            JOptionPane.showMessageDialog(null, "Sync is already running");
        }
    }//GEN-LAST:event_jButtonSyncNowActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonClearLog;
    private javax.swing.JButton jButtonConfigurations;
    private javax.swing.JButton jButtonStartStop;
    private javax.swing.JButton jButtonSyncNow;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabelLastSyncedAt;
    private javax.swing.JLabel jLabelSyncStatus;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextAreaSyncLog;
    // End of variables declaration//GEN-END:variables

    @Override
    public String getTitle() {
        return AppLocal.getIntString("Menu.TillAndBranchSync");
    }

    @Override
    public void activate() throws BasicException {
        enableDisableButtons();
        
        t = new Timer(1000 * 5, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                
                    updateLog();
                
            }
        });
        
        t.start();
    }

    @Override
    public boolean deactivate() {
        
        t.stop();
        
        return true;
    }

    @Override
    public JComponent getComponent() {
        return this;
    }

    @Override
    public void init(AppView app) throws BeanFactoryException {
        
        dlSync = new DataLogicSync();
        dlSync.init(app);
        
            updateLog();
        
    }

    @Override
    public Object getBean() {
        return this;
    }

    private void enableDisableButtons() {
        
        boolean isTillBranchSyncStarted = this.dlSync.isTillBranchSyncStarted();
        
        jButtonSyncNow.setEnabled(isTillBranchSyncStarted);
        if(isTillBranchSyncStarted){
            jButtonStartStop.setText("Stop");
        }
        else {
            jButtonStartStop.setText("Start");
        }
        
        jButtonConfigurations.setEnabled(!isTillBranchSyncStarted);
        
    }
    
    private void updateLog(){
        
        
        try
        {
            boolean isTillBranchSyncStarted = this.dlSync.isTillBranchSyncStarted();
            jLabelSyncStatus.setText( isTillBranchSyncStarted ? "Started" : "Stopped" );

            lastSyncDate = dlSync.getTillBranchLastSyncedAt();
            if(lastSyncDate != null)
            {
                jLabelLastSyncedAt.setText(lastSyncDate.toString());
            }

            List log = dlSync.getTillBranchSyncLog();
            StringBuilder logText = new StringBuilder();
            if(log != null)
            {
                for(int i = log.size() - 1; i >= 0; i--)
                {
                    Object[] var = (Object[])log.get(i);
                    logText.append(var[0].toString() + "\n");
                    logText.append(var[1].toString() + "\n");
                    logText.append("\n");
                }
                
                jTextAreaSyncLog.setText(logText.toString());
            }
        }
        catch(Exception ex)
        {
            Logger.getLogger(JPanelTillBranchSync.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
    }
    
    private void openDbConnections() throws Exception {
        
        if( tillConnection == null || tillConnection.isClosed() ){
            tillConnection = openConnection(AppConfig.getInstance().getProperty("db.user"),
                    AppConfig.getInstance().getProperty("db.password"),
                    AppConfig.getInstance().getProperty("db.URL"));
        }
        
        HashMap map = this.dlSync.getTillBranchSyncConfig();
        
        String branchUser = (String)map.get("BRANCH_DB_USER");
        String branchPassword = (String)map.get("BRANCH_DB_PASSWORD");
        String branchURL = (String)map.get("BRANCH_DB_URL");
        
        if( branchConnection == null || branchConnection.isClosed() ){
            branchConnection = openConnection(branchUser,
                    branchPassword,
                    branchURL);
        }
        
        if(tillConnection == null){
            throw new Exception("Unable to open Till Connection");
        }
        
        if(branchConnection == null){
            throw new Exception("Unable to open Branch Connection");
        }
    }
    
    private Connection openConnection(String sDBUser, String sDBPassword, String sURL) throws Exception {
        
        if (sDBUser != null && sDBPassword != null && sDBPassword.startsWith("crypt:")) {
            AltEncrypter cypher = new AltEncrypter("cypherkey" + sDBUser);
            sDBPassword = cypher.decrypt(sDBPassword.substring(6));
        }
        try {
            DriverManager.setLoginTimeout(10);
            return DriverManager.getConnection(sURL, sDBUser, sDBPassword);
        } catch (SQLException ex) {
            throw ex;
        }
    }
    
    private void insertSyncLog(String log){
        dlSync.insertSyncLog(log);
    }
    
    private void getSiteGuids() throws Exception {
        
        Statement tillConnStmt = null;
        Statement branchConnStmt = null;
        String query = "SELECT * FROM SITEGUID";
        
        try
        {
            tillConnStmt = tillConnection.createStatement();
            ResultSet tillRs = tillConnStmt.executeQuery(query);
            if(tillRs.next()){
                tillSiteGuid = tillRs.getString("GUID");
            }
            
            branchConnStmt = branchConnection.createStatement();
            ResultSet branchRs = branchConnStmt.executeQuery(query);
            if(branchRs.next()){
                branchSiteGuid = branchRs.getString("GUID");
            }
        }
        catch(Exception ex)
        {
            throw ex;
        }
        finally
        {
            if(tillConnStmt != null){
                tillConnStmt.close();
            }
            if(branchConnStmt != null){
                branchConnStmt.close();
            }
        }
        
        
    }
    
    private void syncBranchToTillTable(String tableName, Connection from, Connection to) throws SQLException {

        java.sql.Date sqlDate = new java.sql.Date(0);

        try{
            sqlDate = new java.sql.Date(lastSyncDate.getTime());
        }
        catch(Exception ex){
        }
        
        String query = "select * from "+tableName+" where UPDATED_AT >= '"+sqlDate.toString()+"'";
        
        try (PreparedStatement s1 = from.prepareStatement(query);
             ResultSet rs = s1.executeQuery()) {
            
            insertSyncLog("Sync started for table: " + tableName);
            
            ResultSetMetaData meta = rs.getMetaData();

            List<String> columns = new ArrayList<>();
            for (int i = 1; i <= meta.getColumnCount(); i++)
                columns.add(meta.getColumnName(i));

            String replaceQuery = "REPLACE INTO " + tableName + " ("
                  + columns.stream().collect(Collectors.joining(", "))
                  + ") VALUES ("
                  + columns.stream().map(c -> "?").collect(Collectors.joining(", "))
                  + ")";
            try (PreparedStatement s2 = to.prepareStatement(replaceQuery)) {

                int currentBatchSize = 0;
                while (rs.next()) {
                    for (int i = 1; i <= meta.getColumnCount(); i++)
                    {
                        String columnName = meta.getColumnName(i);
                        
                        if(columnName.equalsIgnoreCase("SITEGUID"))
                        {
                            s2.setObject(i, tillSiteGuid);
                        }
                        else
                        {
                            s2.setObject(i, rs.getObject(i));
                        }
                    }
                    
                    if(currentBatchSize == 0){
                        s2.addBatch("SET FOREIGN_KEY_CHECKS = 0");
                    }

                    s2.addBatch();
                    currentBatchSize++;
                    
                    if(currentBatchSize == batchSize){
                        s2.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                        s2.executeBatch();
                        currentBatchSize = 0;
                    }
                }
                
                s2.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                s2.executeBatch();
            }
            
            insertSyncLog("Sync completed for table: " + tableName);
        }
        
    }
    
    private void syncTillToBranchTable(String tableName, Connection from, Connection to) throws SQLException, Exception {

        java.sql.Date sqlDate = new java.sql.Date(0);

        try{
            sqlDate = new java.sql.Date(lastSyncDate.getTime());
        }
        catch(Exception ex){
        }
        
        String query = "select * from "+tableName+" where is_synced = null or is_synced = 0";
        
        try (PreparedStatement s1 = from.prepareStatement(query);
             ResultSet rs = s1.executeQuery()) {
            
            insertSyncLog("Sync started for table: " + tableName);
            
            ResultSetMetaData meta = rs.getMetaData();

            List<String> columns = new ArrayList<>();
            for (int i = 1; i <= meta.getColumnCount(); i++)
                columns.add(meta.getColumnName(i));

            String replaceQuery = "REPLACE INTO " + tableName + " ("
                  + columns.stream().collect(Collectors.joining(", "))
                  + ") VALUES ("
                  + columns.stream().map(c -> "?").collect(Collectors.joining(", "))
                  + ")";
            
            String updateStockCurrentQuery = "UPDATE STOCKCURRENT SET UNITS = UNITS + ? WHERE PRODUCT = ?";
            
            try (PreparedStatement s2 = to.prepareStatement(replaceQuery);
                    PreparedStatement s3 = createUpdateStatement(from, tableName);
                    PreparedStatement updateStockCurrentStatement = to.prepareStatement(updateStockCurrentQuery)) {

                int currentBatchSize = 0;
                while (rs.next()) {
                    
                    to.setAutoCommit(false);
                    
                    for (int i = 1; i <= meta.getColumnCount(); i++)
                    {
                        String columnName = meta.getColumnName(i);
                        
                        if(columnName.equalsIgnoreCase("SITEGUID"))
                        {
                            s2.setObject(i, tillSiteGuid);
                        }
                        else
                        {
                            s2.setObject(i, rs.getObject(i));
                        }
                    }
                    
                    addParametersToUpdateStatement(s3, rs, tableName);
                    
                    if(currentBatchSize == 0){
                        s2.addBatch("SET FOREIGN_KEY_CHECKS = 0");
                        s3.addBatch("SET FOREIGN_KEY_CHECKS = 0");
                        
                        if(tableName.equalsIgnoreCase("stockdiary"))
                        {
                            updateStockCurrentStatement.addBatch("SET FOREIGN_KEY_CHECKS = 0");
                        }
                    }

                    s2.addBatch();
                    s3.addBatch();
                    if(tableName.equalsIgnoreCase("stockdiary"))
                    {
                        addParametersToUpdateStockCurrentStatement(updateStockCurrentStatement, rs);
                        updateStockCurrentStatement.addBatch();
                    }
                    currentBatchSize++;
                    
                    if(currentBatchSize == batchSize){
                        s2.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                        s2.executeBatch();
                        s3.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                        s3.executeBatch();
                        
                        if(tableName.equalsIgnoreCase("stockdiary"))
                        {
                            updateStockCurrentStatement.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                            updateStockCurrentStatement.executeBatch();
                        }
                        currentBatchSize = 0;
                    }
                    
                    to.commit();
                }
                
                to.setAutoCommit(false);
                
                s2.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                s2.executeBatch();
                
                s3.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                s3.executeBatch();
                
                if(tableName.equalsIgnoreCase("stockdiary"))
                {
                    updateStockCurrentStatement.addBatch("SET FOREIGN_KEY_CHECKS = 1");
                    updateStockCurrentStatement.executeBatch();
                }
                
                to.commit();
            }
            
            insertSyncLog("Sync completed for table: " + tableName);
        }
        
    }
    
    private PreparedStatement createUpdateStatement(Connection conn, String tableName) throws Exception {
        
        PreparedStatement s;
        try
        {
            String query = "UPDATE " + tableName + " SET IS_SYNCED = 1 WHERE ";
            switch (tableName.toUpperCase())
            {
                case "CLOSEDCASH":
                s = conn.prepareStatement(query + "MONEY = ? AND SITEGUID = ?");
                break;
                case "SHIFTS":
                case "SHIFT_BREAKS":
                case "LEAVES":
                case "RESERVATIONS":
                case "RESERVATION_CUSTOMERS":
                case "STOCKDIARY":
                case "RECEIPTS":
                case "TICKETS":
                case "SALES_DENORMALIZED":
                case "PAYMENTS":
                case "TAXLINES":
                case "DRAWEROPENED":
                case "LINEREMOVED":
                s = conn.prepareStatement(query + "ID = ? AND SITEGUID = ?");
                break;
                case "VOUCHERS":
                s = conn.prepareStatement(query + "VOUCHER = ? AND SITEGUID = ?");
                break;
                case "TICKETLINES":
                s = conn.prepareStatement(query + "TICKET = ? AND LINE = ? AND SITEGUID = ?");
                break;
                default:
                    throw new Exception("Unable to create update statement of table: " + tableName);
            }

            return s;
        }
        catch(Exception ex)
        {
            throw new Exception("Unable to create update statement of table: " + tableName + ", Error: " + ex.getMessage());
        }
    }
    
    private void addParametersToUpdateStatement(PreparedStatement s, ResultSet rs, String tableName) throws Exception {
        try
        {
            switch (tableName.toUpperCase())
            {
                case "CLOSEDCASH":
                s.setObject(1, rs.getObject("MONEY"));
                s.setObject(2, rs.getObject("SITEGUID"));
                break;
                case "SHIFTS":
                case "SHIFT_BREAKS":
                case "LEAVES":
                case "RESERVATIONS":
                case "RESERVATION_CUSTOMERS":
                case "STOCKDIARY":
                case "RECEIPTS":
                case "TICKETS":
                case "SALES_DENORMALIZED":
                case "PAYMENTS":
                case "TAXLINES":
                case "DRAWEROPENED":
                case "LINEREMOVED":
                s.setObject(1, rs.getObject("ID"));
                s.setObject(2, rs.getObject("SITEGUID"));
                break;
                case "VOUCHERS":
                s.setObject(1, rs.getObject("VOUCHER"));
                s.setObject(2, rs.getObject("SITEGUID"));
                break;
                case "TICKETLINES":
                s.setObject(1, rs.getObject("TICKET"));
                s.setObject(2, rs.getObject("LINE"));
                s.setObject(3, rs.getObject("SITEGUID"));
                break;
                default:
                    throw new Exception("Unable to add parameters in update statement of table: " + tableName);
            }
        }
        catch(Exception ex)
        {
            throw new Exception("Unable to add parameters in update statement of table: " + tableName);
        }
    }
    
    private void addParametersToUpdateStockCurrentStatement(PreparedStatement updateStockCurrentStatement, ResultSet rs) throws Exception {
     
        try
        {
            // UPDATE STOCKCURRENT SET UNITS = UNITS + ? WHERE PRODUCT = ?
            updateStockCurrentStatement.setObject(1, rs.getObject("UNITS"));
            updateStockCurrentStatement.setObject(2, rs.getObject("PRODUCT"));
        }
        catch(Exception ex)
        {
            throw new Exception("Unable to add parameters in update statement of table: STOCKCURRENT");
        }
    }
    
    public SwingWorker createSyncWorker(){
        
        return new SwingWorker<Boolean, Integer>() {
            @Override
            protected Boolean doInBackground() {
                isPreviousSyncComplete = false;
                
                // Start Progress
                //setProgress(0);
                
                boolean isTillBranchSyncStarted = false;
                
                try
                {
                    isTillBranchSyncStarted = dlSync.isTillBranchSyncStarted();
                }
                catch(Exception ex){
                    ex.printStackTrace();
                }
                
                if(!isTillBranchSyncStarted)
                {
                    return true;
                }

                lastSyncDate = dlSync.getTillBranchLastSyncedAt();
                
                try {
                    openDbConnections();
                } catch (Exception ex) {
                    insertSyncLog("Error: " + ex.getMessage());
                    System.out.println(ex.getMessage());
                    return false;
                }
                
                try {
                    getSiteGuids();
                }
                catch (Exception ex) {
                    insertSyncLog("Error: " + ex.getMessage());
                    System.out.println(ex.getMessage());
                    return false;
                }
                
                // Sync Branch To Till Tables
                for (int i = 0; i < branchToTillTables.length; i++) {
                    try {
                        syncBranchToTillTable(branchToTillTables[i], branchConnection, tillConnection);
                    } catch (Exception ex) {
                        insertSyncLog("Error occurred while syncing Table ("+branchToTillTables[i]+"), Error: " + ex.getMessage());
                        System.out.println(ex.getMessage());
                        return false;
                    }
                }
                
                // Sync Till To Branch Tables
                for (int i = 0; i < tillToBranchTables.length; i++) {
                    try{
                        syncTillToBranchTable(tillToBranchTables[i], tillConnection, branchConnection);
                    } catch (Exception ex) {
                        insertSyncLog("Error occurred while syncing Table ("+branchToTillTables[i]+"), Error: " + ex.getMessage());
                        System.out.println(ex.getMessage());
                        return false;
                    }
                }

                dlSync.updateTillBranchLastSyncedAt();
                // Finished
                return true;
            }

            @Override
            protected void process(List<Integer> chunks) {
                // Get Info
                for (int number : chunks) {
                    
                }
            }
            
            
            
            

            @Override
            protected void done() {
                boolean bStatus = false;
                try {
                    bStatus = get();
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
                insertSyncLog("Till Branch Sync Worker Finished with status " + bStatus);
                System.out.println("Till Branch Sync Worker Finished with status " + bStatus);
                isPreviousSyncComplete = true;
            }
        };
    }

    

    

}
